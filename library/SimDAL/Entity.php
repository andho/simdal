<?php
/**
 * Class Domain Entity
 * Represents an entity in the domain.
 * Usage: declare new entity class with entity name and extend with Domain_Entity Class
 * 
 * @author Amjad Mohamed
 *
 */

class SimDAL_Entity {

	/**
	 * Array of validators that will be used to validate the data in the 
	 * entity in cases where needed (eg. when saving)
	 * 
	 * Passed object must return appropriate data when the data is passed 
	 * to the validator's 'validate' method 
	 *
	 * @var array
	 */
	protected $_validators = array();
	
	/**
	 * Array of filters that will be used to filter the data in the entity
	 * in cases where needed (eg. when saving...)
	 * 
	 * Passed object must return appropriate data when the data is passed
	 * to the filter's 'filter' method
	 *
	 * @var array
	 */
	protected $_filters = array();
	
	/**
	 * Repository class which should be injected when instantiating the object
	 *
	 * @var Domain_Repository
	 */
	protected $_repository;
	
	/**
	 * Array containing the data of the entity
	 *
	 * @var array
	 */
	protected $_data = array();
	
	/**
	 * Array containing child entities that was lazy loaded
	 *
	 * @var array
	 */
	protected $_injected = array();
	
	/**
	 * The properties of the entity that uniquely identifies it
	 *
	 * @var array
	 */
	protected $_identity = array('id');
	
	/**
	 * True if the primary key automatically generated by the 
	 * underlying data persistence layer
	 *
	 * @var boolean
	 */
	protected $_sequence = true;
	
	/**
	 * Contains modified data
	 *
	 * @var array
	 */
	protected $_modified = array();
	
	/**
	 * Restrict injecting more properties than actually in the entity 
	 *
	 * @var boolean
	 */
	protected $_restrict = true;
	
	/**
	 * An Array of relationships of the entity
	 * Each array key corresponds to a property and the value is the
	 * name of the Repository class (which corresponds to the entity class)
	 * for that property
	 *
	 * @var array
	 */
	protected $_relations = array();
	
	/**
	 * Enables the following magic methods
	 * * get<Property> which will return the entity which corresponds to the
	 *   id in the property
	 *
	 * @param string $name
	 * @param array $arguments
	 * @return mixed
	 */
	public function __call($name, $arguments) {
		if (preg_match('/^get(.*)$/', $name, $matches)) {
			$key = strtolower($matches[1]); // @todo should convert from CamelCase to underscore
			if (isset($this->_relations[$key])) {
				return $this->_getPropertyEntity($key);
			}
		}
	}
	
	/**
	 * Returns the Entity of type specified in $entity which correponds
	 * to the id in the appropriate value in the _data property of the
	 * object
	 *
	 * @param string $entity
	 * @return Domain_Entity
	 */
	protected function _getPropertyEntity($entity) {
		$key = $entity;
		
		if ($this->_data[$key] === null) {
			return null;
		}
		
		$repo = new $this->_relations[$key]();
		$entity = $repo->getById($this->_data[$entity]);
		$this->_injected[$key] = $entity;
		
		return $this->_injected[$key];
	}
	
	/**
	 * Constructor for Entity class 
	 * You can pass the Repository into the Entity for convinience functions such as save
	 *
	 * @param array $data data for the entity or configuration options out of which one of them
	 * should be the data
	 * @param Domain_Repository|null $repository
	 */
	public function __construct($data=null, $repository=null) {
		$options = array();
		
		if ($data !== null && isset($data['data'])) {
			$options = $data;
			$data = $data['data'];
		}
		
		if (null !== $data && is_array($data)) {
			if (count($this->_data) > 0 && isset($options['unrestricted']) && $options['unrestricted'] === true) {
				$this->_setDataRestricted($data);
			} else {
				$this->_setData($data);
			}
		} else if (null !== $data && !is_array($data)) {
			throw new Domain_Entity_InvalidDataException("The data provided is not an array");
		}
		
		if ($repository instanceof Domain_Repository ) {
			$this->_repository = $repository;
		}
		if ($this->_repository === null && isset($options['repository'])) {
			$this->_repository = $options['repository'];
		}
		if (is_string($this->_repository) && class_exists($this->_repository)) {
			$repo = new $this->_repository();
			if (!$repo instanceof Domain_Repository ) {
				throw new Exception("Repository in protected property '_repository' should be of tipe Domain_Repository");
			}
			$this->_repository = $repo;
		}
	}
	
	/**
	 * Sets entity data only for properties defined at or before instantiation
	 *
	 * @param array $data
	 */
	public function _setDataRestricted(array $data) {
		foreach (array_keys($this->_data) as $key) {
			if (isset($data[$key])) {
				$this->_data[$key] = $data[$key];
			}
		}
	}
	
	/**
	 * Sets entity data passed from the array matching keys with entity properties
	 *
	 * @param array $data
	 */
	public function _setData(array $data) {
		foreach ($data as $key=>$value) {
			$this->_data[$key] = $value;
		}
	}
	
	/**
	 * Sets entity data passed from array
	 *
	 * @param array $data
	 */
	public function setFromArray(array $data) {
		if (!is_array($data)) {
			throw new Domain_Entity_InvalidDataException("The data provided is not an array");
		}
		
		if ($this->_restrict === true) {
			$this->_setDataRestricted($data);
		} else {
			$this->_setData($data);
		}
	}
	
	/**
	 * Returns the entity data as an array
	 *
	 * @return array
	 */
	public function toArray() {
		return $this->_data;
	}
	
	public function __get($name) {
		if (!isset($this->_data[$name])) {
			return null;
		}
		
		return $this->_data[$name];
	}
	
	public function __set($name, $value) {
		if (!isset($this->_data[$name]) && $this->_data[$name] !== null) {
			return false;
		}
		
		$this->_data[$name] = $value;
	}
	
	public function __isset($name) {
		if (!isset($this->_data[$name])) {
			return false;
		}
		
		return true;
	}
	
	public function __unset($name) {
		if (isset($this->_data[$name])) {
			unset($this->_data[$name]);
		}
	}
	
	public function offsetGet($name) {
		if (!isset($this->_data[$name])) {
			return null;
		}
		
		return $this->_data[$name];
	}
	
	public function offsetSet($name, $value) {
		if (!isset($this->_data[$name]) && $this->_data[$name] !== null) {
			return false;
		}
		
		$this->_data[$name] = $value;
	}
	
	public function offsetExists($name) {
		if (!isset($this->_data[$name])) {
			return false;
		}
		
		return true;
	}
	
	public function offsetUnset($name) {
		if (isset($this->_data[$name])) {
			unset($this->_data[$name]);
		}
	}
	
	/**
	 * Convenienced method that can be used to save the entity
	 *
	 */
	public function save() {
		$this->_repository->save($this);
	}
	
}